{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww12000\viewh14080\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Medium Kahuna\
Software Spec. Top\
10/9/23, v1, Jud\
\
Basic operation is a constant frequency timer interrupt (probably about 1 kHz/1 millisecond) and a real time loop (which occurs as often as it can and has variable frequency/period). The average period of the real time loop needs to be less than half the interrupt timer period. The depth of the queues described below determines just how \'93long term\'94 that average can be.\
\
During the timer interrupt service routine, all inputs are read (polled) and queued (streamed) to the real time loop (main task) and all queued (streamed from the real time loop) outputs are written, if they can be (not blocked/backed up). Each item (event/signal) streamed is given an integer time stamp which is the running count of timer interrupts (which rolls over periodically. No more often than every 32 seconds).\
\
The inputs include the encoder, various switches, and analog to digital channels (wired remote inputs). It does not include serial ports, USB, or other things that the real time loop deals with directly. The outputs include the wired remote outputs (PWM analog channels) and LEDs. When the output items are actually written (by the timer interrupt), they are given a time stamp (current timer interrupt count) and then added back to the input stream (sent back to real time loop). Thus the inputs stream (to the real time loop) contains all the events/signals (Both input and output) with time stamps of when they actually happened.\
\
Various stream processing code objects pick off various streamed items (events/signals) and replaces them in the stream (with same time stamp as original item) and/or adds additional items. For example, Button Up and Button Down items are left in the stream but may cause Click, Double Click and Button Hold items to be added (with same timestamp but behind in stream of items which cause them). The raw encoder A,B channels are read every timer tick and generate an input stream item but, if there is no change in the A,B channels, this item is discarded. If there is a change then, the item is replaced with an item that indicates forward, reverse, or error (1, -1, 0) derived from the, replaced, encoder read item.\
\
The real time loop and the timer interrupt service routine can be considered to be two independent tasks where one task can preempt the other. This requires special considerations when communicating between tasks especially when memory/data is shared between tasks. In most software, sharing information between tasks makes complicated use of semaphores and/or suspending interrupts, etc.  In this application/instance this is all handled, perfectly (no logical holes, no interrupt suspension, inherently stable, simple), by routines in the Signals Library. The Signals Library implements the streams, mentioned above, (just special queues in this case) that allow one task to transmit signals/items/events/data records to another task without issue, regardless of who might preempt who. See the Signal Library documentation for how these special queues work but you just need to know that one task can place items in a special queue and other tasks are notified and can receive it, these queues (streams) are one way, only one task can transmit but many (there is a limit) tasks may receive, the depth of these queues must be set and the tasks using the queues collaborate to avoid overflow (queues have a fixed depth). The queue depths must be exact powers of 2 (1, 2, 4, 8, etc).\
\
All the active wired remote analog input (A/D) channels are read and streamed to the main task (real time loop) every timer tick (timer interrupt), in pretty much raw (maybe some scaling etc) form. An object (filter) in the main task picks off all these analog read events and replaces them with button up and button down events. Another object picks off these button up/down events and adds button click events. If the application is passing through the input wired remote to the output wired remote then a button click event is streamed to (queued for) the timer interrupt handler (input/output task) where it is replaced by button down then button up events which actually output analog values to the wired remote output.\
\
The Signal Processing library is used to process/filter the wired remote input analog sample stream into button down and button up events. These analog streams are actually multilevel digital streams where analog value ranges can indicate the states of several digital bits. The analog values are typically generated by switch and resistor arrays such that each analog range indicates a particular switch closure (button down). The processing operates on the current sample and some number of previous samples (probably 15 to 31 for this application) kept in a queue. It calculates the average value and the running standard deviation of the stream. When the standard deviation goes below a threshold then a list of values is searched for the average value and, if found, a button down event is added to the stream. If the standard deviation is greater than the threshold or the value is not found in the table, then a button up event is streamed. \
\
\
Item components\
Timestamp 16 bits unsigned, count of timer ticks, rolls over every 15 to 128 seconds\
Type   16 bits from table of types, like, button down, encoder update, A/D value\
Type index/Subtype  16 bits, tells which button, encoder, A/D channel, odd/even means original/feedback\
General Value  16 bits unsigned  typically left justified if A/D, D/A value, or data type\
2nd General Value 32 bits signed, fixed binary point, pointer\
\
Item Types\
ButtonUp, ButtonDown, ButtonClick, ButtonDouble, ButtonHold\
DigitalIn\
DigitalOut\
DigitalOutFeedback\
EncoderRawRead\
EncoderUpdate\
AnalogRead\
AnalogWrite\
AnalogWriteFeedback\
ParameterGet\
ParameterSet\
ParameterSetFeedBack\
TimeUpdate\
\
Tentative Nano pins\
\pard\pardeftab720\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
Two W/R inputs is 2 analog Voltage inputs, 2 analog/pwm calibrated current outputs.\
Two W/R outputs is two analog/pwm voltage outputs, 2 analog current inputs.\
Two analog in for Vbat, Vref\
Six switch/button/encoder up to 2 encoders (2 each) 2 switches, 1 encoder four switches\
Three PWM LED drivers\
One digital out for pulling in reference resistor or other circuit control (calibration mode)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
3 pwm outputs for LEDs\
4 analog outputs (pwm with filter) W/R interface\
4 an\cf0 \kerning1\expnd0\expndtw0 a\cf2 \expnd0\expndtw0\kerning0
log Inputs connects to four 2to1 multiplexers, \
     bank 0 connects to 4 W/R analog channels, bank 1 connects to  Vbat and V+6 and 2 spare\
1 digital output to select analog input mux bank\
1 digital output for circuit control\
3 digital outputs to select 8 to 1 digital input mux\
    2 x 2 encoders 4 switch/buttons \
1 digital input from 8 to 1 digital input mux\
3 digital I/O for I2C or SPI, use standard I2C pins (A4 and A5) and last pin to accommodate SPI if possible \
20 total\cf0 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}