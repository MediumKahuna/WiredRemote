{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww12000\viewh14080\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Medium Kahuna\
Software Spec. Top\
10/9/23, v1, Jud\
\
Basic operation is a constant frequency timer interrupt (probably about 1 kHz/1 millisecond) and a real time loop (which occurs as often as it can and has variable frequency/period). The average period of the real time loop needs to be less than half the interrupt timer period. The depth of the queues described below determines just how \'93long term\'94 that average can be.\
\
During the timer interrupt service routine, all inputs are read (polled) and queued (streamed) to the real time loop (main task) and all queued (streamed from the real time loop) outputs are written, if they can be (not blocked/backed up). Each item (event/signal) streamed is given an integer time stamp which is the running count of timer interrupts (which rolls over periodically. No more often than every 32 seconds).\
\
The inputs include the encoder, various switches, and analog to digital channels (wired remote inputs). It does not include serial ports, USB, or other things that the real time loop deals with directly. The outputs include the wired remote outputs (PWM analog channels) and LEDs. When the output items are actually written (by the timer interrupt), they are given a time stamp (current timer interrupt count) and then added back to the input stream (sent back to real time loop). Thus the inputs stream (to the real time loop) contains all the events/signals (Both input and output) with time stamps of when they actually happened.\
\
Various stream processing code objects pick off various streamed items (events/signals) and replaces them in the stream (with same time stamp as original item) and/or adds additional items. For example, Button Up and Button Down items are left in the stream but may cause Click, Double Click and Button Hold items to be added (with same timestamp but behind in stream of items which cause them). The raw encoder A,B channels are read every timer tick and generate an input stream item but, if there is no change in the A,B channels, this item is discarded. If there is a change then, the item is replaced with an item that indicates forward, reverse, or error (1, -1, 0) derived from the encoder read item.\
\
The real time loop and the timer interrupt service routine can be considered to be two independent tasks where one task can preempt the other. This requires special considerations when communicating between tasks especially when memory/data is shared between tasks. In most software, sharing information between tasks makes complicated use of semaphores and/or suspending interrupts, etc.  In this application/instance this is all handled, perfectly (no logical holes, no interrupt suspension, inherently stable, simple), by routines in the Signals Library. The Signals Library implements the streams, mentioned above, (just special queues in this case) that allow one task to transmit signals/items/events/data records to another task without issue, regardless of who might preempt who. See the Signal Library documentation for how these special queues work but you just need to know that one task can place items in a special queue and other tasks are notified and can receive it, these queues (streams) are one way, only one task can transmit but many (there is a limit) tasks may receive, the depth of these queues must be set and the tasks using the queues collaborate to avoid overflow (queues have a fixed depth). The queue depths must be exact powers of 2 (1, 2, 4, 8 etc).\
\
All the active wired remote analog input (A/D) channels are read and streamed to the main task (real time loop) every timer tick (timer interrupt), in pretty much raw (maybe some scaling etc) form. An object in the main task picks off all these analog read events and replaces them with button up and button down events. Another object picks off these button up/down events and adds button click events. If the application is passing through the input wired remote to the output wired remote then a button click event is streamed to (queued for) the timer interrupt handler (input/output task) where it is replace by button down then button up events which actually output analog values to the wired remote output.\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}